# **LLM APIサーバー 段階的要件定義書**

## **1\. 概要**

本ドキュメントは、10パターンの固定クエリに対するLLM応答（各5バリエーション）を、低コストかつ高パフォーマンスで提供するAPIサーバーの構想と、その実現に向けた段階的な開発計画を定義するものである。

プロジェクトは3つのフェーズで構成される。まず、既存資産を流用して迅速に価値を証明し（フェーズ1）、次にサーバーレス化でコストと運用を最適化（フェーズ2）、最終的に要件に特化した究極の静的配信モデルへと進化させる（フェーズ3）。

## **2\. フェーズ1: Nginxキャッシュによる迅速なサービスイン**

### **2.1. 背景と目的**

プロジェクトの初期段階として、まずはPoC（概念実証）を迅速に完了させることを最優先とする。既存のNginxリバースプロキシ環境を最小限の変更で活用し、GPUインスタンスを一切稼働させずにサービスを即時リリースする。

**目的**:

* 超高速・高安定な応答APIを数時間以内に実装し、サービスの価値を証明する。  
* 稼働時のコンピューティングコストをNginxサーバーの維持費のみに抑制する。

### **2.2. アーキテクチャ**

既存のNginxリバースプロキシにディスクキャッシュ機能を追加する。バックエンドのLLMサーバーは、キャッシュを生成するためのデータソースとして**一度だけ**利用する。

graph TD  
    subgraph "事前準備 (一度だけ実行)"  
        A\[LLMサーバー\] \--\>|応答を生成しキャッシュさせる| B(Nginxキャッシュ)  
    end

    subgraph "通常運用時"  
        C(ユーザー) \--\>|APIリクエスト| B  
        B \--\>|キャッシュから即時応答| C  
    end

    style A fill:\#f9f,stroke:\#333,stroke-width:2px

### **2.3. 要件**

1. **事前生成データ**: 10クエリ × 5バリエーション \= 50個の応答を事前にLLMで生成する。  
2. **Nginx設定**: proxy\_cache\_path と proxy\_cache ディレクティブを使用し、ディスクキャッシュを有効化する。  
3. **データ永続化**: Dockerの名前付きボリュームを使用し、Nginxコンテナを再作成してもキャッシュが消えないようにする。  
4. **運用自動化**: curl を用いたシェルスクリプト (warmup.sh) と Makefile を導入し、キャッシュの生成（ウォームアップ）と管理を自動化・標準化する。

## **3\. フェーズ2: Lambda \+ DynamoDBによるサーバーレス化**

### **3.1. 背景と目的**

フェーズ1のPoC成功を受け、より堅牢でスケーラブルな本番環境へと移行する。常時稼働するNginxサーバーを廃止し、リクエストがない時のアイドルコストを完全にゼロにすることを目的とする。また、将来的に動的なクエリ応答が必要になった際の拡張性を確保する。

**目的**:

* 完全サーバーレス化により、アイドルコストをゼロにする。  
* 未知のクエリに対してGPUをオンデマンドで起動するなど、将来の機能拡張の礎を築く。

### **3.2. アーキテクチャ**

APIの全リクエストをAPI GatewayとLambdaで受け、応答データはDynamoDBで管理する。

graph TD  
    A(ユーザー) \--\>|APIリクエスト| B\[API Gateway\]  
    B \--\>|リクエストをトリガー| C{AWS Lambda}  
    C \--\>|データをクエリ| D\[(Amazon DynamoDB)\]  
    D \--\>|応答データを返す| C  
    C \--\>|応答を返す| B  
    B \--\>|API応答| A

### **3.3. 要件**

1. **データストア (Amazon DynamoDB)**: 事前生成した50個の応答データをDynamoDBに格納する。テーブル設計は、元のプロンプトをパーティションキー、応答のバリエーション番号をソートキーとする。  
2. **APIエンドポイント (Amazon API Gateway)**: HTTPリクエストを受け付け、バックエンドのLambda関数をトリガーする。  
3. **ビジネスロジック (AWS Lambda)**: API Gatewayからのリクエストに基づき、DynamoDBからランダムなバリエーションの応答を取得して返す。

## **4\. フェーズ3: 静的配信による究極の最適化（最終形）**

### **4.1. 背景と目的**

プロジェクトの要件が「完全に固定された10パターンのクエリ」であることから、動的なサーバーサイド処理は不要であると結論付けた。コスト、パフォーマンス、スケーラビリティ、運用シンプルさの全てを極限まで最適化するため、完全な静的配信モデルを採用する。

**目的**:

* サーバーサイドのロジックを完全に排除し、インフラを究極にシンプルにする。  
* CDNを活用し、世界中のどこからでも最速の応答速度を実現する。

### **4.2. アーキテクチャ**

**Amazon S3**をオリジンサーバーとし、**Amazon CloudFront (CDN)** を介してコンテンツを配信する、典型的な静的ウェブホスティング構成を採用する。

graph TD  
    A(クライアント) \--\>|ランダムなURLをリクエスト\<br\>例: /.../q1/2.json| B\[Amazon CloudFront (CDN)\]  
    subgraph AWS  
        B \-- "キャッシュミス時のみ" \--\> C\[(Amazon S3)\]  
    end  
    B \--\>|JSONファイルを高速配信| A

### **4.3. 要件**

1. **データ準備**: 50個の応答をそれぞれJSONファイルとして保存する ({"response": "..."})。  
2. **S3バケットとファイル構造**:  
   * 静的ウェブサイトホスティングを有効にしたS3バケットを用意する。  
   * 命名規則に従い、ファイルを配置する。  
     * **ベースパス**: /responses/  
     * **クエリごとのフォルダ名**: q1\_capital, q2\_battle など。  
     * **応答ファイル名**: 0.json, 1.json など。  
     * **ファイルパス例**: /responses/q1\_capital/0.json  
3. **CDN (Amazon CloudFront)**: S3バケットをオリジンとするCloudFrontディストリビューションを作成し、コンテンツをキャッシュ配信させる。  
4. **クライアント側の実装**: APIの利用側が、プロンプトに対応するパスとランダムなファイル名を組み合わせてリクエストURLを動的に生成する。

### **4.4. 期待される成果**

* **コスト**: サーバーのアイドルコストが完全にゼロになり、S3の微々たる保管料とCloudFrontの転送料のみという究極の低コスト運用が実現する。  
* **パフォーマンス**: すべての応答がユーザーに最も近いCDNエッジからミリ秒単位で返され、最高のユーザー体験を提供する。  
* **運用**: サーバーのパッチ適用やコードのデプロイといった運用作業が一切不要になる。コンテンツの更新はS3へのファイルアップロードのみで完結する。
